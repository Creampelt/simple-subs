/**
 * @file Handles actions to manipulate app state.
 * @author Emily Sturman <emily@sturman.org>
 */
import "react-native-get-random-values";
import { Alert } from "react-native";
import { firestore, auth, authErrorMessage, firestoreErrorMessage } from "../constants/Firebase";
import moment from "moment";
import { toISO } from "../constants/Date";

// All possible actions to edit state
const Actions = {
  UPDATE_ORDERS: "UPDATE_ORDERS",
  UPDATE_USER_DATA: "UPDATE_USER_DATA",
  UPDATE_CONSTANTS: "UPDATE_CONSTANTS",
  UPDATE_PRESETS: "UPDATE_PRESETS",
  FOCUS_ORDER: "FOCUS_ORDER",
  FOCUS_PRESET: "FOCUS_PRESET",
  SET_MODAL_PROPS: "SET_MODAL_PROPS",
  SET_INFO_MESSAGE: "SET_INFO_MESSAGE",
  SET_LOADING: "SET_LOADING"
};

export default Actions;

/**
 * Firebase collection containing all orders (for pushing orders).
 * @param {string} uid Unique identifier for currently authenticated user.
 * @return {CollectionReference} Reference to collection containing user's orders.
 */
const allOrders = firestore.collection("allOrders");

/**
 * Firebase collection containing user's orders (for pulling orders).
 * @param {string} uid Unique identifier for currently authenticated user.
 * @return {CollectionReference} Reference to collection containing user's orders.
 */
const myOrders = (uid) => allOrders.where("uid", "==", uid);

/**
 * Gets Firestore document containing user's profile information.
 * @param {string} uid Unique identifier for currently authenticated user.
 * @return {DocumentReference<T>} Reference to document containing user's profile information.
 */
const myUserData = (uid) => firestore.collection("userData").doc(uid);

/**
 * Gets Firebase collection containing user's order presets.
 * @param {string} uid Unique identifier for currently authenticated user.
 * @return {CollectionReference} Reference to collection containing user's order presets.
 */
const myPresets = (uid) => (
  firestore.collection("userData")
    .doc(uid)
    .collection("myPresets")
);

/**
 * Opens an alert for an error provided by Firebase Auth.
 * @param {function} dispatch Dispatch function passed from Redux.
 * @param {auth.Error} error Error from Firebase Auth.
 */
const alertAuthError = (dispatch, error) => {
  dispatch(stopLoading());
  const { title, message } = authErrorMessage(error);
  Alert.alert(title, message);
};

/**
 * Opens an alert for an error provided by Firestore.
 * @param {function} dispatch Dispatch function passed from Redux.
 * @param {Error} error Error from Firestore.
 */
const alertFirestoreError = (dispatch, error) => {
  dispatch(stopLoading());
  const { title, message } = firestoreErrorMessage(error);
  Alert.alert(title, message);
};

/**
 * Action to execute on success of Firebase action.
 *
 * Stops app loading and displays a success message in
 * top-level info modal.
 *
 * @param {string}   message  Message to display in info modal.
 * @param {function} dispatch Dispatch function passed from Redux.
 */
const successAction = (message, dispatch) => {
  dispatch(stopLoading());
  dispatch(setInfoMessage(message));
};

/**
 * Creates a new sandwich order.
 *
 * Converts date to ISO format and pushes order data to Firebase.
 *
 * @param {function} dispatch  Dispatch function passed from Redux.
 * @param {Object}   data      Order data to push to Firebase.
 * @param {string}   data.date Order date in readable format.
 * @param {string}   uid       ID unique to authenticated user (generated by Firebase Auth).
 */
export const createOrder = (dispatch, data, uid) => {
  dispatch(startLoading());
  let dataToPush = { ...data, date: toISO(data.date), uid };
  return (
    allOrders
      .add(dataToPush)
      .then(() => successAction("Order created successfully", dispatch))
      .catch((error) => alertFirestoreError(dispatch, error))
  );
};

/**
 * Edits an existing sandwich order.
 *
 * Converts date to ISO format and pushes order to Firebase; edits
 * doc if date is the same, otherwise deletes old doc and creates
 * new with updated date.
 *
 * @param {function} dispatch  Dispatch function passed from Redux.
 * @param {Object}   data      Order data to push to Firebase.
 * @param {string}   data.date Order date in readable format.
 * @param {string}   id        ID of order being edited (generated by Firebase).
 * @param {string}   uid       ID unique to authenticated user (generated by Firebase Auth).
 */
export const editOrder = (dispatch, data, id, uid) => {
  dispatch(startLoading());
  let dataToPush = { ...data, date: toISO(data.date), uid };
  return (
    allOrders
      .doc(id)
      .set(dataToPush)
      .then(() => successAction("Order updated successfully", dispatch))
      .catch((error) => alertFirestoreError(dispatch, error))
  );
};

/**
 * Deletes an existing sandwich order.
 *
 * Deletes doc corresponding to order from Firestore.
 *
 * @param {function} dispatch Dispatch function passes from Redux.
 * @param {string}   id       ID of order being edited generated by Firebase).
 */
export const deleteOrder = (dispatch, id) => {
  dispatch(startLoading());
  return (
    allOrders.doc(id)
      .delete()
      .then(() => successAction("Order deleted successfully", dispatch))
      .catch((error) => alertFirestoreError(dispatch, error))
  );
};

/**
 * Creates a new order preset.
 *
 * Pushes preset to Firebase with order title as unique identifying key.
 *
 * @param {function} dispatch   Dispatch function passed from Redux.
 * @param {Object}   data       Order data to push to Firebase.
 * @param {string}   uid        ID unique to authenticated user (generated by Firebase Auth).
 */
export const createPreset = (dispatch, data, uid) => {
  dispatch(startLoading());
  return (
    myPresets(uid)
      .add(data)
      .then(() => successAction("Preset created successfully", dispatch))
      .catch((error) => alertFirestoreError(dispatch, error))
  );
};

/**
 * Edits an existing order preset.
 *
 * Edits doc if title is the same, otherwise deletes old doc and creates
 * new with updated title.
 *
 * @param {function} dispatch   Dispatch function passed from Redux.
 * @param {Object}   data       Preset data to push to Firebase.
 * @param {string}   data.title Title of order preset.
 * @param {string}   id         ID of order being edited (original title of preset).
 * @param {string}   uid        ID unique to authenticated user (generated by Firebase Auth).
 */
export const editPreset = (dispatch, data, id, uid) => {
  dispatch(startLoading());
  let dataToPush = { ...data };
  delete dataToPush.key;
  return myPresets(uid).doc(id)
    .set(dataToPush)
    .then(() => successAction("Preset updated successfully", dispatch))
    .catch((error) => alertFirestoreError(dispatch, error))
};

/**
 * Deletes an existing order preset.
 *
 * Deletes doc corresponding to preset from Firestore.
 *
 * @param {function} dispatch Dispatch function passed from Redux.
 * @param {string}   id       ID of preset being edited (title of preset).
 * @param {string}   uid      ID unique to authenticated user (generated by Firebase Auth).
 */
export const deletePreset = (dispatch, id, uid) => {
  dispatch(startLoading());
  return (
    myPresets(uid).doc(id)
      .delete()
      .then(() => successAction("Preset deleted successfully", dispatch))
      .catch((error) => alertFirestoreError(dispatch, error))
  );
};

/**
 * Sets loading state of app to true.
 * @return {Object} Object to pass to dispatch function.
 */
export const startLoading = () => ({
  type: Actions.SET_LOADING,
  loading: true
})

/**
 * Sets loading state of app to false.
 * @return {Object} Object to pass to dispatch function.
 */
export const stopLoading = () => ({
  type: Actions.SET_LOADING,
  loading: false
})

/**
 * Sets focused order in app state to given ID.
 *
 * @param {string} id Unique order ID (date in ISO format).
 *
 * @return {Object} Object to pass to dispatch function.
 */
export const focusOrder = (id) => ({
  type: Actions.FOCUS_ORDER,
  id
});

/**
 * Sets focused order in app state to null.
 * @return {Object} Object to pass to dispatch function.
 */
export const unfocusOrder = () => ({
  type: Actions.FOCUS_ORDER,
  id: null
});

/**
 * Sets focused preset in app state to given ID.
 *
 * @param {string} id Unique preset ID (title of preset).
 *
 * @return {Object} Object to pass to dispatch function.
 */
export const focusPreset = (id) => ({
  type: Actions.FOCUS_PRESET,
  id
});

/**
 * Sets focused preset in app state to null.
 * @return {Object} Object to pass to dispatch function.
 */
export const unfocusPreset = () => ({
  type: Actions.FOCUS_PRESET,
  id: null
})

/**
 * Logs user in using provided auth credentials.
 *
 * Uses Firebase Auth's standard email/password account management
 * to authenticate user with given email address and password.
 *
 * @param {function} dispatch Dispatch function passed from Redux.
 * @param {string}   email    User's email address.
 * @param {string}   password Password for user's account.
 */
export const logIn = (dispatch, email, password) => {
  dispatch(startLoading());
  auth().signInWithEmailAndPassword(email, password)
    .then(() => dispatch(stopLoading()))
    .catch((error) => alertAuthError(dispatch, error));
};

/**
 * Logs user out using Firebase Auth.
 * @param {function} dispatch Dispatch function passed from Redux.
 */
export const logOut = (dispatch) => {
  dispatch(startLoading());
  auth().signOut()
    .then(() => dispatch(stopLoading()))
    .catch((error) => alertAuthError(dispatch, error))
};

/**
 * Edits user's profile data.
 *
 * Updates doc corresponding to currently authenticated user
 * (identified through user ID).
 *
 * @param {function} dispatch Dispatch function passed from Redux.
 * @param {Object}   data     Profile data to push to Firebase.
 * @param {string}   uid      ID unique to authenticated user (generated by Firebase Auth).
 */
export const editUserData = (dispatch, data, uid) => {
  dispatch(startLoading());
  let newData = { ...data };
  delete newData.uid;
  firestore.collection("userData")
    .doc(uid)
    .set(newData)
    .then(() => successAction("User data updated successfully", dispatch))
    .catch((error) => alertFirestoreError(dispatch, error));
};

/**
 * Creates a new user.
 *
 * Creates user using Firebase Auth's email/password account management
 * and pushes profile information to Firestore.
 *
 * @param {function} dispatch Dispatch function passed from Redux.
 * @param {string}   email    User's email address.
 * @param {string}   password Password for user's account.
 * @param {Object}   data     Profile information to push to Firebase.
 */
export const createUser = (dispatch, email, password, data) => {
  dispatch(startLoading());
  auth().createUserWithEmailAndPassword(email, password)
    .then((userCredential) => editUserData(dispatch, data, userCredential.user.uid))
    .catch((error) => alertAuthError(dispatch, error));
}

/**
 * Opens top-level modal with provided props.
 *
 * @param {Object} props Props to pass to modal.
 *
 * @return {Object} Object to pass to dispatch function.
 */
export const openModal = (props) => ({
  type: Actions.SET_MODAL_PROPS,
  props: { ...props, open: true }
});

/**
 * Sets top-level modal props (without opening).
 *
 * @param {Object} props Props to pass to modal.
 *
 * @return {Object} Object to pass to dispatch function.
 */
export const setModalProps = (props) => ({
  type: Actions.SET_MODAL_PROPS,
  props
});

/**
 * Closes top-level modal.
 * @return {Object} Object to pass to dispatch function.
 */
export const closeModal = () => ({
  type: Actions.SET_MODAL_PROPS,
  props: { open: false }
});

/**
 * Sets message for top-level info modal.
 *
 * @param {string} message Message to be displayed in info modal.
 *
 * @return {Object} Object to pass to dispatch function.
 */
export const setInfoMessage = (message) => ({
  type: Actions.SET_INFO_MESSAGE,
  message
});

/**
 * Updates order state from data pulled from Firebase.
 *
 * Reads each doc from snapshot of orders collection and adds
 * to orders state.
 *
 * @param {QuerySnapshot<T>} querySnapshot Collection snapshot from orders collection listener.
 *
 * @return {Object} Object to pass to dispatch function.
 */
export const updateOrders = (querySnapshot) => {
  let orders = {};
  querySnapshot.forEach((doc) => {
    let data = {
      ...doc.data(),
      date: moment(doc.data().date),
      key: doc.id
    };
    delete data.uid;
    orders[doc.id] = data;
  });
  return {
    type: Actions.UPDATE_ORDERS,
    orders
  };
};

/**
 * Updates preset state from data pulled from Firebase.
 *
 * Reads each doc from snapshot of presets collection and adds
 * to preset state.
 *
 * @param {QuerySnapshot<T>} querySnapshot Collection snapshot from preset collection listener.
 *
 * @return {Object} Object to pass to dispatch function.
 */
export const updatePresets = (querySnapshot) => {
  let presets = {};
  querySnapshot.forEach((doc) => {
    presets[doc.id] = {
      ...doc.data(),
      key: doc.id
    }
  });
  return {
    type: Actions.UPDATE_PRESETS,
    presets
  }
}

/**
 * Logs in user in app state (sets user object to empty object).
 * @return {Object} Object to pass to dispatch function.
 */
export const logInAction = () => ({
  type: Actions.UPDATE_USER_DATA,
  data: {}
})

/**
 * Updates profile data in app state.
 *
 * @param {string}              uid ID unique to authenticated user (generated by Firebase Auth).
 * @param {DocumentSnapshot<T>} doc Doc containing user data.
 *
 * @return {Object} Object to pass to dispatch function.
 */
export const updateUserData = (uid, doc) => ({
  type: Actions.UPDATE_USER_DATA,
  data: {uid, email: auth().currentUser.email, ...doc.data()}
});

/**
 * Logs out user in app state (sets user object to null).
 * @return {Object} Object to pass to dispatch function.
 */
export const logOutAction = () => ({
  type: Actions.UPDATE_USER_DATA,
  data: null
});

/**
 * Sets a password reset email to given email address.
 *
 * @param {function} dispatch Dispatch function passed from Redux.
 * @param {string}   email    Email address to send password reset email to.
 */
export const resetPassword = (dispatch, email) => {
  dispatch(startLoading());
  auth().sendPasswordResetEmail(email)
    .then(() => successAction("Email sent successfully", dispatch))
    .catch((error) => alertAuthError(dispatch, error));
};

/**
 * Re-authenticates user and changes user's account password.
 *
 * @param {function} dispatch        Dispatch function passed from Redux.
 * @param {string}   currentPassword User's current account password.
 * @param {string}   newPassword     User's new account password.
 */
export const changePassword = (dispatch, currentPassword, newPassword) => {
  dispatch(startLoading());
  const user = auth().currentUser;
  const credential = auth.EmailAuthProvider.credential(user.email, currentPassword);
  user.reauthenticateWithCredential(credential).then(() => (
    user.updatePassword(newPassword)
      .then(() => successAction("Password set successfully", dispatch))
      .catch((error) => alertAuthError(dispatch, error))
  )).catch((error) => alertAuthError(dispatch, error));
}

/**
 * Updates state constants with provided data.
 *
 * @param {Object}                         data            Data to set in state.
 * @param {{hour: number, minute: number}} data.cutoffTime Cutoff time for placing new orders.
 *
 * @return {Object} Object to pass to dispatch function.
 */
export const updateConstants = (data) => ({
  type: Actions.UPDATE_CONSTANTS,
  data: {
    ...data,
    cutoffTime: moment(data.cutoffTime)
  }
});

/**
 * Creates listener for user's orders collection.
 *
 * @param {function} dispatch Dispatch function passed from Redux.
 * @param {string}   uid      ID unique to authenticated user (generated by Firebase Auth).
 *
 * @return {function} Function to unsubscribe listener.
 */
export const watchOrders = (dispatch, uid) => (
  myOrders(uid).onSnapshot(
    (querySnapshot) => dispatch(updateOrders(querySnapshot)),
    (error) => alertFirestoreError(dispatch, error)
  )
);

/**
 * Creates listener for user profile data.
 *
 * @param {function} dispatch Dispatch function passed from Redux.
 * @param {string}   uid      ID unique to authenticated user (generated by Firebase Auth).
 *
 * @return {function} Function to unsubscribe listener.
 */
export const watchUserData = (dispatch, uid) => (
  myUserData(uid).onSnapshot(
    (doc) => dispatch(updateUserData(uid, doc)),
    (error) => alertFirestoreError(dispatch, error)
  )
);

/**
 * Creates listener for user's presets collection.
 *
 * @param {function} dispatch Dispatch function passed from Redux.
 * @param {string}   uid      ID unique to authenticated user (generated by Firebase Auth).
 *
 * @return {function} Function to unsubscribe listener.
 */
export const watchPresets = (dispatch, uid) => (
  myPresets(uid).onSnapshot(
    (querySnapshot) => dispatch(updatePresets(querySnapshot)),
    (error) => alertFirestoreError(dispatch, error)
  )
);

/**
 * Creates listener for user authentication state (logged in or out).
 *
 * @param {function} dispatch Dispatch function passed from Redux.
 *
 * @return {firebase.Unsubscribe} Function to unsubscribe listener.
 */
export const watchAuthState = (dispatch) => (
  auth().onAuthStateChanged((user) => {
    if (user) {
      dispatch(logInAction());
    } else {
      dispatch(logOutAction());
    }
  })
);

/**
 * Creates listener for app constants when user is not authenticated.
 *
 * @param {function} dispatch  Dispatch function passed from Redux.
 * @param {function} onSuccess Function to execute if operation is successful.
 * @param {function} onError   Function to execute if operation fails.
 *
 * @return {function} Function to unsubscribe listener.
 */
export const getUnauthData = (dispatch, onSuccess, onError) => (
  firestore.collection("appData")
    .doc("appConstants")
    .get()
    .then((doc) => {
      dispatch(updateConstants(doc.data()));
      onSuccess();
    }).catch((error) => {
      alertFirestoreError(dispatch, error);
      onError();
    })
);

/**
 * Creates listener for app constants when user is authenticated.
 *
 * @param {function} dispatch  Dispatch function passed from Redux.
 * @param {function} onSuccess Function to execute if operation is successful.
 * @param {function} onError   Function to execute if operation fails.
 *
 * @return {Promise} Function to unsubscribe listener.
 */
export const getAuthData = (dispatch, onSuccess, onError) => {
  const uid = auth().currentUser.uid;
  return (
    Promise.all([
      myOrders(uid).get(),
      myUserData(uid).get(),
      firestore.collection("appData").doc("appConstants").get(),
      myPresets(uid).get()
    ]).then((results) => {
      const [ordersSnapshot, userData, stateConstants, presetsSnapshot] = results;
      dispatch(updateOrders(ordersSnapshot));
      dispatch(updateUserData(uid, userData));
      dispatch(updateConstants(stateConstants.data()));
      dispatch(updatePresets(presetsSnapshot));
      onSuccess();
    }).catch((error) => {
      alertFirestoreError(dispatch, error);
      onError();
    })
  )
};